{"ast":null,"code":"(function (scope) {\n  'use strict';\n\n  var pubsubInstance = null;\n  var pubsubConfig = null;\n\n  if (typeof pubsub === 'object') {\n    pubsubConfig = pubsub; //node.js config from global\n  } else if (typeof global === 'object' && typeof global.pubsubConfig === 'object') {\n    pubsubConfig = global.pubsubConfig;\n  }\n\n  function Pubsub(config) {\n    var _eventObject = {};\n    var options = {\n      separator: config && config.separator ? config.separator : '/',\n      recurrent: config && typeof config.recurrent === 'boolean' ? config.recurrent : false,\n      depth: config && typeof config.depth === 'number' ? config.depth : null,\n      async: config && typeof config.async === 'boolean' ? config.async : false,\n      context: config && config.context ? config.context : null,\n      log: config && config.log ? config.log : false\n    };\n\n    function forEach(dataArray, callback) {\n      var i = 0,\n          arrayLength = dataArray.length;\n\n      for (i = 0; i < arrayLength; i++) {\n        callback(i, dataArray[i]);\n      }\n    }\n\n    function isArray(obj) {\n      return Array.isArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\n    }\n\n    function executeCallback(subscriptions, args, async) {\n      async = typeof async === 'boolean' ? async : options.async;\n\n      if (!subscriptions.length) {\n        return;\n      } // clone array - callbacks can unsubscribe other subscriptions\n      // reduces a lot performance but is safe\n\n\n      var executedSubscriptions = subscriptions.slice();\n      forEach(executedSubscriptions, function (subscriptionId, subscription) {\n        if (typeof subscription === 'object' && executedSubscriptions.hasOwnProperty(subscriptionId)) {\n          if (async) {\n            setTimeout(function () {\n              subscription.callback.apply(subscription.context, args);\n            }, 4);\n          } else {\n            subscription.callback.apply(subscription.context, args);\n          }\n        }\n      });\n    }\n\n    function executePublishWildcard(nsObject, args) {\n      var nsElement;\n\n      for (nsElement in nsObject) {\n        if (nsElement[0] !== '_' && nsObject.hasOwnProperty(nsElement)) {\n          executeCallback(nsObject[nsElement]._events, args);\n        }\n      }\n    }\n\n    function publish(nsObject, args, parts, params) {\n      // work on copy - not on reference\n      parts = parts.slice();\n      var iPart = parts.shift();\n      var depth = params.depth;\n      var async = params.async;\n      var partsLength = params.partsLength;\n      var recurrent = params.recurrent;\n      var partNumber = partsLength - parts.length; // parts is empty\n\n      if (!iPart) {\n        executeCallback(nsObject._events, args, async);\n        return;\n      } // handle subscribe wildcard\n\n\n      if (typeof nsObject['*'] !== 'undefined') {\n        publish(nsObject['*'], args, parts, params);\n      } // handle publish wildcard\n\n\n      if (iPart === '*') {\n        executePublishWildcard(nsObject, args, async);\n      } // no namespace = leave publish\n\n\n      if (typeof nsObject[iPart] === \"undefined\") {\n        if (params.log) {\n          console.warn('There is no ' + params.nsString + ' subscription');\n        }\n\n        return;\n      }\n\n      nsObject = nsObject[iPart];\n\n      if (recurrent === true && typeof depth !== 'number') {\n        //depth is not defined\n        executeCallback(nsObject._events, args, async);\n\n        if (parts.length === 0) {\n          return;\n        }\n      } else if (recurrent === true && typeof depth === 'number' && partNumber >= partsLength - depth) {\n        //if depth is defined\n        executeCallback(nsObject._events, args, async);\n      }\n\n      publish(nsObject, args, parts, params);\n    }\n\n    function executeSubscribeWildcard(nsObject, args, params) {\n      var parts = params.parts;\n      var async = params.async;\n      var nextPart = null;\n\n      if (parts.length === 0) {\n        executeCallback(nsObject._events, args, async);\n      } else {\n        nextPart = parts.shift();\n\n        if (nsObject[nextPart]) {\n          executeSubscribeWildcard(nsObject[nextPart], args, {\n            parts: parts,\n            async: async,\n            nsString: params.nsString\n          });\n        }\n      }\n    }\n\n    function subscribe(nsString, callback, params) {\n      var parts = nsString.split(options.separator),\n          nsObject,\n          //Namespace object to which we attach event\n      context = params && typeof params.context !== 'undefined' ? params.context : options.context,\n          eventObject = null,\n          i = 0;\n\n      if (!context) {\n        context = callback;\n      } //Iterating through _eventObject to find proper nsObject\n\n\n      nsObject = _eventObject;\n\n      for (i = 0; i < parts.length; i += 1) {\n        if (typeof nsObject[parts[i]] === \"undefined\") {\n          nsObject[parts[i]] = {};\n          nsObject[parts[i]]._events = [];\n        }\n\n        nsObject = nsObject[parts[i]];\n      }\n\n      eventObject = {\n        callback: callback,\n        context: context // \"this\" parameter in executed function\n\n      };\n\n      nsObject._events.push(eventObject);\n\n      return {\n        namespace: parts.join(options.separator),\n        event: eventObject\n      };\n    }\n\n    function unsubscribe(subscribeObject) {\n      if (subscribeObject === null || typeof subscribeObject === 'undefined') {\n        return null;\n      }\n\n      var nsString = subscribeObject.namespace,\n          eventObject = subscribeObject.event,\n          parts = nsString.split(options.separator),\n          nsObject,\n          i = 0; //Iterating through _eventObject to find proper nsObject\n\n      nsObject = _eventObject;\n\n      for (i = 0; i < parts.length; i += 1) {\n        if (typeof nsObject[parts[i]] === \"undefined\") {\n          if (options.log) {\n            console.error('There is no ' + nsString + ' subscription');\n          }\n\n          return null;\n        }\n\n        nsObject = nsObject[parts[i]];\n      }\n\n      forEach(nsObject._events, function (eventId) {\n        if (nsObject._events[eventId] === eventObject) {\n          nsObject._events.splice(eventId, 1);\n        }\n      });\n    }\n\n    return {\n      /**\n       * Publish event\n       * @param nsString string namespace string splited by dots\n       * @param args array of arguments given to callbacks\n       * @param params paramaters possible:\n       *        @param recurrent bool should execution be bubbled throught namespace\n       *        @param depth integer how many namespaces separated by dots will be executed\n       */\n      publish: function (nsString, args, params) {\n        var parts = nsString.split(options.separator),\n            recurrent = typeof params === 'object' && params.recurrent ? params.recurrent : options.recurrent,\n            // bubbles event throught namespace if true\n        depth = typeof params === 'object' && params.depth ? params.depth : options.depth,\n            async = typeof params === 'object' && params.async ? params.async : options.async,\n            partsLength = parts.length;\n\n        if (!parts.length) {\n          if (options.log) {\n            console.error('Wrong namespace provided ' + nsString);\n          }\n\n          return;\n        }\n\n        publish(_eventObject, args, parts, {\n          recurrent: recurrent,\n          depth: depth,\n          async: async,\n          parts: parts,\n          nsString: nsString,\n          partsLength: partsLength\n        });\n      },\n\n      /**\n       * Subscribe event\n       * @param nsString string namespace string splited by dots\n       * @param callback function function executed after publishing event\n       * @param params given params\n       *\t\t@param context object/nothing Optional object which will be used as \"this\" in callback\n       */\n      subscribe: function (nsString, callback, params) {\n        var self = this,\n            subscriptions = []; // array of callbacks - multiple subscription\n\n        if (isArray(callback)) {\n          forEach(callback, function (number) {\n            var oneCallback = callback[number];\n            subscriptions = subscriptions.concat(self.subscribe(nsString, oneCallback, params));\n          }); // array of namespaces - multiple subscription\n        } else if (isArray(nsString)) {\n          forEach(nsString, function (number) {\n            var namespace = nsString[number];\n            subscriptions = subscriptions.concat(self.subscribe(namespace, callback, params));\n          });\n        } else {\n          return subscribe.apply(self, arguments);\n        }\n\n        return subscriptions;\n      },\n\n      /**\n       * subscribeOnce event - subscribe once to some event, then unsubscribe immadiately\n       * @param nsString string namespace string splited by dots\n       * @param callback function function executed after publishing event\n       * @param params given params\n       *\t\t@param context object/nothing Optional object which will be used as \"this\" in callback\n       */\n      subscribeOnce: function (nsString, callback, params) {\n        var self = this,\n            subscription = null;\n\n        function subscriptionCallback() {\n          var context = this;\n          callback.apply(context, arguments);\n          self.unsubscribe(subscription);\n        }\n\n        subscription = self.subscribe(nsString, subscriptionCallback, params);\n        return subscription;\n      },\n\n      /**\n       * Unsubscribe from given subscription\n       * @param subscribeObject subscription object given on subscribe (returned from subscription)\n       */\n      unsubscribe: function (subscribeObject) {\n        var self = this; //if we have array of callbacks - multiple subscription\n\n        if (isArray(subscribeObject)) {\n          forEach(subscribeObject, function (number) {\n            var oneSubscribtion = subscribeObject[number];\n            unsubscribe.apply(self, [oneSubscribtion]);\n          });\n        } else {\n          unsubscribe.apply(self, arguments);\n        }\n      },\n\n      /**\n       * newInstance - makes new instance of pubsub object with its own config\n       * @param params instance configuration\n       *        @param separator separator (default is \"/\")\n       *        @param recurrent should publish events be bubbled through namespace\n       *        @param async should publish events be asynchronous - not blocking function execution\n       *        @param log console.warn/error every problem\n       */\n      newInstance: function (params) {\n        return new Pubsub(params);\n      }\n    }; //return block\n  }\n\n  pubsubInstance = new Pubsub(pubsubConfig); //if sbd's using requirejs library to load pubsub.js\n\n  if (typeof define === 'function') {\n    define(pubsubInstance);\n  } //node.js\n\n\n  if (typeof module === 'object' && module.exports) {\n    module.exports = pubsubInstance;\n  }\n\n  if (typeof window === 'object') {\n    window.pubsub = pubsubInstance;\n\n    if (window !== scope) {\n      scope.pubsub = pubsubInstance;\n    }\n  }\n})(this);","map":{"version":3,"sources":["/Users/rock/Desktop/react_project04/node_modules/pubsub.js/pubsub.js"],"names":["scope","pubsubInstance","pubsubConfig","pubsub","global","Pubsub","config","_eventObject","options","separator","recurrent","depth","async","context","log","forEach","dataArray","callback","i","arrayLength","length","isArray","obj","Array","Object","prototype","toString","call","executeCallback","subscriptions","args","executedSubscriptions","slice","subscriptionId","subscription","hasOwnProperty","setTimeout","apply","executePublishWildcard","nsObject","nsElement","_events","publish","parts","params","iPart","shift","partsLength","partNumber","console","warn","nsString","executeSubscribeWildcard","nextPart","subscribe","split","eventObject","push","namespace","join","event","unsubscribe","subscribeObject","error","eventId","splice","self","number","oneCallback","concat","arguments","subscribeOnce","subscriptionCallback","oneSubscribtion","newInstance","define","module","exports","window"],"mappings":"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","sourcesContent":["(function(scope) {\n\t'use strict';\n\tvar pubsubInstance = null;\n\tvar pubsubConfig = null;\n\n\tif(typeof pubsub === 'object') {\n\t\tpubsubConfig = pubsub;\n\t//node.js config from global\n\t} else if(typeof global === 'object' && typeof global.pubsubConfig === 'object') {\n\t\tpubsubConfig = global.pubsubConfig;\n\t}\n\n\tfunction Pubsub(config) {\n\t\tvar _eventObject = {};\n\t\tvar options = {\n\t\t\tseparator : (config && config.separator) ? config.separator : '/',\n\t\t\trecurrent : (config && typeof config.recurrent === 'boolean') ? config.recurrent : (false),\n\t\t\tdepth     : (config && typeof config.depth === 'number') ? config.depth : null,\n\t\t\tasync     : (config && typeof config.async === 'boolean') ? config.async : (false),\n\t\t\tcontext   : (config && config.context) ? config.context : null,\n\t\t\tlog       : (config && config.log) ? config.log : (false)\n\t\t};\n\n\t\tfunction forEach(dataArray, callback) {\n\t\t\tvar i = 0,\n\t\t\t\tarrayLength = dataArray.length;\n\n\t\t\tfor(i = 0; i < arrayLength; i++) {\n\t\t\t\tcallback(i, dataArray[i]);\n\t\t\t}\n\t\t}\n\n        function isArray (obj) {\n\t\t\treturn Array.isArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\n        }\n\n        function executeCallback(subscriptions, args, async) {\n\t\t\tasync = (typeof async === 'boolean') ? async : options.async;\n\t\t\tif(!subscriptions.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// clone array - callbacks can unsubscribe other subscriptions\n\t\t\t// reduces a lot performance but is safe\n\t\t\tvar executedSubscriptions = subscriptions.slice();\n\n\t\t\tforEach(executedSubscriptions, function(subscriptionId, subscription) {\n\t\t\t\tif(typeof subscription === 'object' && executedSubscriptions.hasOwnProperty(subscriptionId)) {\n\t\t\t\t\tif(async) {\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tsubscription.callback.apply(subscription.context, args);\n\t\t\t\t\t\t}, 4);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubscription.callback.apply(subscription.context, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction executePublishWildcard(nsObject, args) {\n\t\t\tvar nsElement;\n\t\t\tfor(nsElement in nsObject) {\n\t\t\t\tif(nsElement[0] !== '_' && nsObject.hasOwnProperty(nsElement)) {\n\t\t\t\t\texecuteCallback(nsObject[nsElement]._events, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction publish(nsObject, args, parts, params) {\n\t\t\t// work on copy - not on reference\n\t\t\tparts = parts.slice();\n\n\t\t\tvar iPart = parts.shift();\n\t\t\tvar depth = params.depth;\n\t\t\tvar async = params.async;\n\t\t\tvar partsLength = params.partsLength;\n\t\t\tvar recurrent = params.recurrent;\n\t\t\tvar partNumber = (partsLength - parts.length);\n\n\t\t\t// parts is empty\n\t\t\tif(!iPart) {\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// handle subscribe wildcard\n\t\t\tif(typeof nsObject['*'] !== 'undefined') {\n\t\t\t\tpublish(nsObject['*'], args, parts, params);\n\t\t\t}\n\n\t\t\t// handle publish wildcard\n\t\t\tif(iPart === '*') {\n\t\t\t\texecutePublishWildcard(nsObject, args, async);\n\t\t\t}\n\n\t\t\t// no namespace = leave publish\n\t\t\tif(typeof nsObject[iPart] === \"undefined\") {\n\t\t\t\tif(params.log) {\n\t\t\t\t\tconsole.warn('There is no ' + params.nsString + ' subscription');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnsObject = nsObject[iPart];\n\n\t\t\tif(recurrent === true && typeof depth !== 'number') { //depth is not defined\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t\tif(parts.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if(recurrent === true && typeof depth === 'number' && partNumber >= (partsLength - depth)) { //if depth is defined\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t}\n\n\t\t\tpublish(nsObject, args, parts, params);\n\t\t}\n\n\t\tfunction executeSubscribeWildcard(nsObject, args, params) {\n\t\t\tvar parts = params.parts;\n\t\t\tvar async = params.async;\n\t\t\tvar nextPart = null;\n\n\t\t\tif(parts.length === 0) {\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t} else {\n\t\t\t\tnextPart = parts.shift();\n\n\t\t\t\tif(nsObject[nextPart]) {\n\t\t\t\t\texecuteSubscribeWildcard(nsObject[nextPart], args, {\n\t\t\t\t\t\tparts : parts,\n\t\t\t\t\t\tasync : async,\n\t\t\t\t\t\tnsString : params.nsString\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction subscribe(nsString, callback, params) {\n\t\t\tvar parts = nsString.split(options.separator),\n\t\t\t\tnsObject, //Namespace object to which we attach event\n\t\t\t\tcontext = (params && typeof params.context !== 'undefined') ? params.context : options.context,\n\t\t\t\teventObject = null,\n\t\t\t\ti = 0;\n\n\t\t\tif(!context) {\n\t\t\t\tcontext = callback;\n\t\t\t}\n\n\t\t\t//Iterating through _eventObject to find proper nsObject\n\t\t\tnsObject = _eventObject;\n\t\t\tfor(i = 0; i < parts.length; i += 1) {\n\t\t\t\tif(typeof nsObject[parts[i]] === \"undefined\") {\n\t\t\t\t\tnsObject[parts[i]] = {};\n\t\t\t\t\tnsObject[parts[i]]._events = [];\n\t\t\t\t}\n\t\t\t\tnsObject = nsObject[parts[i]];\n\t\t\t}\n\n\t\t\teventObject = {\n\t\t\t\tcallback\t: callback,\n\t\t\t\tcontext\t\t: context // \"this\" parameter in executed function\n\t\t\t};\n\n\t\t\tnsObject._events.push(eventObject);\n\t\t\treturn { namespace : parts.join(options.separator),\n\t\t\t\tevent : eventObject };\n\t\t}\n\n\t\tfunction unsubscribe(subscribeObject) {\n\t\t\tif(subscribeObject === null || typeof subscribeObject === 'undefined') {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar nsString = subscribeObject.namespace,\n\t\t\t\teventObject = subscribeObject.event,\n\t\t\t\tparts = nsString.split(options.separator),\n\t\t\t\tnsObject,\n\t\t\t\ti = 0;\n\n\t\t\t//Iterating through _eventObject to find proper nsObject\n\t\t\tnsObject = _eventObject;\n\t\t\tfor(i = 0; i < parts.length; i += 1) {\n\t\t\t\tif(typeof nsObject[parts[i]] === \"undefined\") {\n\t\t\t\t\tif(options.log) {\n\t\t\t\t\t\tconsole.error('There is no ' + nsString + ' subscription');\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tnsObject = nsObject[parts[i]];\n\t\t\t}\n\n\t\t\tforEach(nsObject._events, function(eventId) {\n\t\t\t\tif(nsObject._events[eventId] === eventObject) {\n\t\t\t\t\tnsObject._events.splice(eventId, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\t/**\n\t\t\t * Publish event\n\t\t\t * @param nsString string namespace string splited by dots\n\t\t\t * @param args array of arguments given to callbacks\n\t\t\t * @param params paramaters possible:\n\t\t\t *        @param recurrent bool should execution be bubbled throught namespace\n\t\t\t *        @param depth integer how many namespaces separated by dots will be executed\n\t\t\t */\n\t\t\tpublish : function(nsString, args, params) {\n\t\t\t\tvar parts = nsString.split(options.separator),\n\t\t\t\t\trecurrent = (typeof params === 'object' && params.recurrent) ? params.recurrent : options.recurrent, // bubbles event throught namespace if true\n\t\t\t\t\tdepth = (typeof params === 'object' && params.depth) ? params.depth : options.depth,\n\t\t\t\t\tasync = (typeof params === 'object' && params.async) ? params.async : options.async,\n\t\t\t\t\tpartsLength = parts.length;\n\n\t\t\t\tif(!parts.length) {\n\t\t\t\t\tif(options.log) {\n\t\t\t\t\t\tconsole.error('Wrong namespace provided ' + nsString);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tpublish(_eventObject, args, parts, {\n\t\t\t\t\trecurrent : recurrent,\n\t\t\t\t\tdepth : depth,\n\t\t\t\t\tasync : async,\n\t\t\t\t\tparts : parts,\n\t\t\t\t\tnsString : nsString,\n\t\t\t\t\tpartsLength : partsLength\n\t\t\t\t});\n\t\t\t},\n\t\t\t/**\n\t\t\t * Subscribe event\n\t\t\t * @param nsString string namespace string splited by dots\n\t\t\t * @param callback function function executed after publishing event\n\t\t\t * @param params given params\n\t\t\t *\t\t@param context object/nothing Optional object which will be used as \"this\" in callback\n\t\t\t */\n\t\t\tsubscribe : function(nsString, callback, params) {\n\t\t\t\tvar self = this,\n\t\t\t\t\tsubscriptions = [];\n\n\t\t\t\t// array of callbacks - multiple subscription\n\t\t\t\tif(isArray(callback)) {\n\t\t\t\t\tforEach(callback, function(number) {\n\t\t\t\t\t\tvar oneCallback = callback[number];\n\n\t\t\t\t\t\tsubscriptions =\tsubscriptions.concat(self.subscribe(nsString, oneCallback, params));\n\t\t\t\t\t});\n\t\t\t\t// array of namespaces - multiple subscription\n\t\t\t\t} else if(isArray(nsString)) {\n\t\t\t\t\tforEach(nsString, function(number) {\n\t\t\t\t\t\tvar namespace = nsString[number];\n\n\t\t\t\t\t\tsubscriptions =\tsubscriptions.concat(self.subscribe(namespace, callback, params));\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn subscribe.apply(self, arguments);\n\t\t\t\t}\n\t\t\t\treturn subscriptions;\n\t\t\t},\n\t\t\t/**\n\t\t\t * subscribeOnce event - subscribe once to some event, then unsubscribe immadiately\n\t\t\t * @param nsString string namespace string splited by dots\n\t\t\t * @param callback function function executed after publishing event\n\t\t\t * @param params given params\n\t\t\t *\t\t@param context object/nothing Optional object which will be used as \"this\" in callback\n\t\t\t */\n\t\t\tsubscribeOnce : function(nsString, callback, params) {\n\t\t\t\tvar self = this,\n\t\t\t\t\tsubscription = null;\n\n\t\t\t\tfunction subscriptionCallback() {\n\t\t\t\t\tvar context = this;\n\n\t\t\t\t\tcallback.apply(context, arguments);\n\t\t\t\t\tself.unsubscribe(subscription);\n\t\t\t\t}\n\n\t\t\t\tsubscription = self.subscribe(nsString, subscriptionCallback, params);\n\t\t\t\treturn subscription;\n\t\t\t},\n\t\t\t/**\n\t\t\t * Unsubscribe from given subscription\n\t\t\t * @param subscribeObject subscription object given on subscribe (returned from subscription)\n\t\t\t */\n\t\t\tunsubscribe : function(subscribeObject) {\n\t\t\t\tvar self = this;\n\n\t\t\t\t//if we have array of callbacks - multiple subscription\n\t\t\t\tif(isArray(subscribeObject)) {\n\t\t\t\t\tforEach(subscribeObject, function(number) {\n\t\t\t\t\t\tvar oneSubscribtion = subscribeObject[number];\n\n\t\t\t\t\t\tunsubscribe.apply(self, [oneSubscribtion]);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tunsubscribe.apply(self, arguments);\n\t\t\t\t}\n\t\t\t},\n\t\t\t/**\n\t\t\t * newInstance - makes new instance of pubsub object with its own config\n\t\t\t * @param params instance configuration\n\t\t\t *        @param separator separator (default is \"/\")\n\t\t\t *        @param recurrent should publish events be bubbled through namespace\n\t\t\t *        @param async should publish events be asynchronous - not blocking function execution\n\t\t\t *        @param log console.warn/error every problem\n\t\t\t */\n\t\t\tnewInstance : function(params) {\n\t\t\t\treturn new Pubsub(params);\n\t\t\t}\n\t\t}; //return block\n\t}\n\tpubsubInstance = new Pubsub(pubsubConfig);\n\n\t//if sbd's using requirejs library to load pubsub.js\n\tif(typeof define === 'function') {\n\t\tdefine(pubsubInstance);\n\t}\n\n\t//node.js\n\tif(typeof module === 'object' && module.exports) {\n\t\tmodule.exports = pubsubInstance;\n\t}\n\n\tif(typeof window === 'object') {\n\t\twindow.pubsub = pubsubInstance;\n\t\tif(window !== scope) {\n\t\t\tscope.pubsub = pubsubInstance;\n\t\t}\n\t}\n})(this);\n"]},"metadata":{},"sourceType":"script"}